### MVVMについて  

**Model View ViewModel**はソフトウェアアーキテクチャパターンのひとつである。  
GUIを持つアプリケーションをModel,View,ViewModelの3つに分割して設計・実装を行う。  

  MVCの派生パターンであり、PresentationModelパターンの直系。  
```
  Model View Controller  
1. model: アプリケーションデータ、ビジネスルール、ロジック、関数  
2. view: グラフや図などの任意の情報表現  
3. controller: 入力を受け取りmodelとviewへの命令に変換する  
```
元々はMicrosoftのWPFやSilverlightで生まれ、AndroidやWeb上のJavaScriptでも利用が増えている。  

#### MVVMの構成要素  

##### View  
**View**の役割というのは2つある。
1. **ViewModel**の情報を用いてのUIを描画すること。  
2. **ViewModel**にUserが入力した情報を送信すること。  
  
上記の役割しか持たないので、複雑なロジックや状態を持つことがない。
##### ViewModel  

**View**を描画するための状態保持、  
**View**から受け取った情報を適切な状態にして**Model**に送る,  
また**Model**の情報を**View**に送る役割をもつ。  
**View**との情報伝達に際して、データバインディング機構のようなものを通じて行う為、**ViewModel**を変更すると**View**に自動的に反映されるようになっている。


##### Model  

アプリケーション上の問題領域を担い、そのアプリ領域のデータと手続きを行う。  
アプリケーションの多くでデータ格納にDBを用いたり、端末外のサーバとの通信を行う処理が含まれている。  
そういった、**View**や**ViewModel**では行わない処理を担当する部分が**Model**であると言える。  

##### 3つの連携について

**Model**,**View**,**ViewModel**の3者の連携については一方通行的にしかそれぞれの存在を知ることがない。  
**View**は**ViewModel**を知るが、**Model**は知らない。  
**ViewModel**は**Model**を知るが、**View**は知らない。  
**Model**は他のものを知らない。  
ここで言う「知らない」は知る必要がないと言うことであるが、  
**Model**は描画に関わることがないが、描画に関わる情報の保持については制約がない。  
保持されている情報は**ViewModel**を介して**View**に反映される。

**ViewModel**は**Model**に対して、**Model**を操作するための戻り地のないメソッド、**Model**のステート公開と変更通知を受けることができる。  
**ViewModel**が**Model**に対してパラメータの変更メソッドを呼んだとき、**Model**はその変更メソッド内でそのパラメータが変更されたことを**Listener**に向けて通知する。
以上のことから、**Model**はステートフルである。


MVVMやその元になったMVCなどの目的は、見た目をデザインする作業と中の開発の作業を完全に分割し、作業の効率を上げることにある。  
そのためには**ViewModel**の仕様が決まっている必要がある。  
**View**とはデータバインディングでしか繋がっていないからできる芸当である。  
デザイナーは**View**しか触らないし、**ViewModel**とバインドされている情報さえ与えられていれば**Model**の状態を気にする必要がない。  
なので、開発は**View**に提示する情報の提示処理のみに目を向けて作業をすることができるようになる。

